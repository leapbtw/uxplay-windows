; Script generated by the Inno Setup Script Wizard.
; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!

#define MyAppName "uxplay-windows"
#define MyAppVersion "1.72"
#define MyAppPublisher "leapbtw"
#define MyAppURL "https://github.com/leapbtw/uxplay-windows"
#define MyAppExeName "uxplay-windows.exe"

[Setup]
; NOTE: The value of AppId uniquely identifies this application. Do not use the same AppId value in installers for other applications.
; (To generate a new GUID, click Tools | Generate GUID inside the IDE.)
AppId={{02621F03-7F92-4E33-AA17-017F79B31DCF}
AppName={#MyAppName}
AppVersion={#MyAppVersion}
;AppVerName={#MyAppName} {#MyAppVersion}
AppPublisher={#MyAppPublisher}
AppPublisherURL={#MyAppURL}
AppSupportURL={#MyAppURL}
AppUpdatesURL={#MyAppURL}
DefaultDirName={autopf}\{#MyAppName}
DisableProgramGroupPage=yes
; Uncomment the following line to run in non administrative install mode (install for current user only.)
;PrivilegesRequired=lowest
OutputBaseFilename=uxplay-windows
SetupIconFile=D:\a\uxplay-windows\uxplay-windows\icon.ico
Compression=lzma
SolidCompression=yes
WizardStyle=modern
UninstallDisplayIcon={app}\{#MyAppExeName}
; Enhanced uninstall settings
CloseApplications=force
RestartApplications=no
; This setting allows us to handle everything in the uninstall process
UninstallRestartComputer=no

[Languages]
Name: "english"; MessagesFile: "compiler:Default.isl"

[Tasks]
Name: "desktopicon"; Description: "{cm:CreateDesktopIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: unchecked

[Files]
Source: "D:\a\uxplay-windows\uxplay-windows\dist\uxplay-windows\{#MyAppExeName}"; DestDir: "{app}"; Flags: ignoreversion
Source: "D:\a\uxplay-windows\uxplay-windows\dist\uxplay-windows\*"; DestDir: "{app}"; Flags: ignoreversion recursesubdirs createallsubdirs
; NOTE: Don't use "Flags: ignoreversion" on any shared system files

; Temporary files for Bonjour installation if needed
Source: "{tmp}\BonjourPSSetup.exe"; DestDir: "{tmp}"; Flags: deleteafterinstall external; ExternalSize: 2000000; Check: not IsBonjourInstalled

[Icons]
Name: "{autoprograms}\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"
Name: "{autodesktop}\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"; Tasks: desktopicon

[Run]
; Install Bonjour if not already installed
Filename: "{tmp}\BonjourPSSetup.exe"; Parameters: "/extract"; Flags: waituntilterminated runhidden; Check: not IsBonjourInstalled
Filename: "cmd.exe"; Parameters: "/c expand ""{tmp}\BonjourPS.msi"" -F:* ""{tmp}"""; Flags: waituntilterminated runhidden; Check: not IsBonjourInstalled
Filename: "msiexec.exe"; Parameters: "/i ""{tmp}\Bonjour64.msi"" /qn"; Flags: waituntilterminated; StatusMsg: "Installing Bonjour..."; Check: not IsBonjourInstalled

; Launch the application after installation
Filename: "{app}\{#MyAppExeName}"; Description: "{cm:LaunchProgram,{#StringChange(MyAppName, '&', '&&')}}"; Flags: shellexec postinstall skipifsilent

[UninstallRun]
; First terminate any running instances more aggressively
Filename: "taskkill.exe"; Parameters: "/f /im {#MyAppExeName}"; Flags: runhidden skipifdoesntexist

[InstallDelete]
; Clean up any leftover files during installation/reinstallation
Type: filesandordirs; Name: "{app}"

[UninstallDelete]
; Make absolutely sure we delete everything during uninstall
Type: filesandordirs; Name: "{app}"

[Code]
// Function to check if Bonjour is installed by checking registry key
function IsBonjourInstalled: Boolean;
begin
  Result := RegKeyExists(HKEY_LOCAL_MACHINE, 'SYSTEM\CurrentControlSet\Services\Bonjour Service');
  if Result then
    Log('Bonjour Service is already installed.')
  else
    Log('Bonjour Service is not installed. Will download and install it.');
end;

// Function to download Bonjour installer if not installed
function PrepareToInstall(var NeedsRestart: Boolean): String;
var
  DownloadPage: TDownloadWizardPage;
begin
  Result := '';
  
  // If Bonjour is not installed, download the installer
  if not IsBonjourInstalled then
  begin
    DownloadPage := CreateDownloadPage(SetupMessage(msgWizardPreparing), SetupMessage(msgPreparingDesc), nil);
    
    DownloadPage.Add('https://download.info.apple.com/Mac_OS_X/061-8098.20100603.gthyu/BonjourPSSetup.exe', 'BonjourPSSetup.exe', '');
    DownloadPage.Show;
    try
      try
        DownloadPage.Download;
        Result := '';
      except
        Result := 'Error downloading Bonjour. ' + GetExceptionMessage;
      end;
    finally
      DownloadPage.Hide;
    end;
  end;
end;

// Show a message during installation indicating Bonjour installation status
procedure CurStepChanged(CurStep: TSetupStep);
begin
  if CurStep = ssInstall then
  begin
    if not IsBonjourInstalled then
      Log('Will install Bonjour as part of the setup.')
    else
      Log('Skipping Bonjour installation as it is already installed.');
  end;
end;

// Helper function to check if a process is running
function IsProcessRunning(const ProcessName: string): Boolean;
var
  ResultCode: Integer;
begin
  // Using tasklist to check if process is running, redirecting output to nul
  // Exit code 0 means process was found, 1 means it wasn't
  if Exec('cmd.exe', '/c tasklist /FI "IMAGENAME eq ' + ProcessName + '" /NH | find "' + ProcessName + '" > nul', '', SW_HIDE, ewWaitUntilTerminated, ResultCode) then
    Result := (ResultCode = 0)
  else
    Result := False; // If command failed, assume process is not running
end;

// Function to terminate a process
function TerminateProcess(const ProcessName: string; ForceTerminate: Boolean): Boolean;
var
  ResultCode: Integer;
  Params: string;
begin
  if ForceTerminate then
    Params := '/f /im ' + ProcessName
  else
    Params := '/im ' + ProcessName;
    
  Result := Exec('taskkill.exe', Params, '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
end;

// Function to handle uninstallation initialization
function InitializeUninstall(): Boolean;
var
  UninstallBonjour: Boolean;
begin
  Result := True;
  
  // First check if our app is running and terminate it with increasing force
  if IsProcessRunning('{#MyAppExeName}') then
  begin
    Log('Application is running. Attempting to close it gracefully...');
    TerminateProcess('{#MyAppExeName}', False);
    
    // Wait a bit for the application to close
    Sleep(1000);
    
    // If still running, force kill
    if IsProcessRunning('{#MyAppExeName}') then
    begin
      Log('Application still running. Forcing termination...');
      TerminateProcess('{#MyAppExeName}', True);
      Sleep(2000); // Wait longer after forced termination
    end;
  end;
  
  // Ask if user wants to uninstall Bonjour as well
  if IsBonjourInstalled then
  begin
    UninstallBonjour := MsgBox('Would you like to uninstall Bonjour as well?' + #13#10 + 
                              '(Note: Only uninstall if no other applications need it)',
                              mbConfirmation, MB_YESNO) = IDYES;
                              
    if UninstallBonjour then
    begin
      Log('User chose to uninstall Bonjour. Executing uninstaller...');
      // Get the Bonjour uninstall string from registry
      // This approach is more reliable than hardcoding a GUID
      if Exec('wmic', 'product where "name like ''Bonjour''" call uninstall /nointeractive', '', SW_HIDE, ewWaitUntilTerminated, ResultCode) then
        Log('Bonjour uninstall command executed successfully')
      else
        Log('Failed to execute Bonjour uninstall command');
    end;
  end;
end;

// Function to handle post-uninstall cleanup, ensuring all files are removed
procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep);
var
  AppPath: string;
begin
  if CurUninstallStep = usPostUninstall then
  begin
    AppPath := ExpandConstant('{app}');
    
    // Double-check if the directory still exists
    if DirExists(AppPath) then
    begin
      Log('Application directory still exists after uninstall. Attempting final cleanup...');
      
      // Make sure no processes are locking the directory
      if IsProcessRunning('{#MyAppExeName}') then
      begin
        Log('Application process still found. Forcing termination...');
        TerminateProcess('{#MyAppExeName}', True);
        Sleep(3000); // Wait even longer to ensure process is fully terminated
      end;
      
      // Final attempt to remove the directory
      if not DelTree(AppPath, True, True, True) then
      begin
        Log('Failed to remove directory using DelTree. Attempting with cmd...');
        // Try with RD command which sometimes works better
        Exec('cmd.exe', '/c rd /s /q "' + AppPath + '"', '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
      end;
      
      // Inform user if we couldn't remove everything
      if DirExists(AppPath) then
        Log('WARNING: Could not completely remove application directory.')
      else
        Log('Application directory successfully removed.');
    end;
  end;
end;
