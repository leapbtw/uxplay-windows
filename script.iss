; Script generated by the Inno Setup Script Wizard.
; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!

#define MyAppName "uxplay-windows"
#define MyAppVersion "1.72"
#define MyAppPublisher "leapbtw"
#define MyAppURL "https://github.com/leapbtw/uxplay-windows"
#define MyAppExeName "uxplay-windows.exe"

[Setup]
; NOTE: The value of AppId uniquely identifies this application. Do not use the same AppId value in installers for other applications.
; (To generate a new GUID, click Tools | Generate GUID inside the IDE.)
AppId={{02621F03-7F92-4E33-AA17-017F79B31DCF}
AppName={#MyAppName}
AppVersion={#MyAppVersion}
;AppVerName={#MyAppName} {#MyAppVersion}
AppPublisher={#MyAppPublisher}
AppPublisherURL={#MyAppURL}
AppSupportURL={#MyAppURL}
AppUpdatesURL={#MyAppURL}
DefaultDirName={autopf}\{#MyAppName}
DisableProgramGroupPage=yes
; Uncomment the following line to run in non administrative install mode (install for current user only.)
;PrivilegesRequired=lowest
OutputBaseFilename=uxplay-windows
SetupIconFile=D:\a\uxplay-windows\uxplay-windows\icon.ico
Compression=lzma
SolidCompression=yes
WizardStyle=modern
UninstallDisplayIcon={app}\{#MyAppExeName}
; Enhanced uninstall settings
CloseApplications=force
RestartApplications=no
; This setting allows us to handle everything in the uninstall process
UninstallRestartComputer=no

[Languages]
Name: "english"; MessagesFile: "compiler:Default.isl"

[Tasks]
Name: "desktopicon"; Description: "{cm:CreateDesktopIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: unchecked

[Files]
Source: "D:\a\uxplay-windows\uxplay-windows\dist\uxplay-windows\{#MyAppExeName}"; DestDir: "{app}"; Flags: ignoreversion
Source: "D:\a\uxplay-windows\uxplay-windows\dist\uxplay-windows\*"; DestDir: "{app}"; Flags: ignoreversion recursesubdirs createallsubdirs
; NOTE: Don't use "Flags: ignoreversion" on any shared system files

; Temporary files for Bonjour installation if needed
Source: "{tmp}\BonjourPSSetup.exe"; DestDir: "{tmp}"; Flags: deleteafterinstall external; ExternalSize: 2000000; Check: not IsBonjourInstalled

[Icons]
Name: "{autoprograms}\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"
Name: "{autodesktop}\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"; Tasks: desktopicon

[Run]
; Install Bonjour if not already installed
Filename: "{tmp}\BonjourPSSetup.exe"; Parameters: "/extract"; Flags: waituntilterminated runhidden; Check: not IsBonjourInstalled; StatusMsg: "Preparing Bonjour installation (required for AirPlay)..."
Filename: "cmd.exe"; Parameters: "/c expand ""{tmp}\BonjourPS.msi"" -F:* ""{tmp}"""; Flags: waituntilterminated runhidden; Check: not IsBonjourInstalled
Filename: "msiexec.exe"; Parameters: "/i ""{tmp}\Bonjour64.msi"" /qn"; Flags: waituntilterminated; StatusMsg: "Installing Bonjour (required for AirPlay)..."; Check: not IsBonjourInstalled

; Launch the application after installation
Filename: "{app}\{#MyAppExeName}"; Description: "{cm:LaunchProgram,{#StringChange(MyAppName, '&', '&&')}}"; Flags: shellexec postinstall skipifsilent

[UninstallRun]
; First terminate any running instances more aggressively
Filename: "taskkill.exe"; Parameters: "/f /im {#MyAppExeName}"; Flags: runhidden skipifdoesntexist
; Also terminate uxplay.exe which might be a separate process
Filename: "taskkill.exe"; Parameters: "/f /im uxplay.exe"; Flags: runhidden skipifdoesntexist

[InstallDelete]
; Clean up any leftover files during installation/reinstallation
Type: filesandordirs; Name: "{app}"

[UninstallDelete]
; Make absolutely sure we delete everything during uninstall
Type: filesandordirs; Name: "{app}"

[Code]
// Function to check if Bonjour is installed by checking registry key
function IsBonjourInstalled: Boolean;
begin
  Result := RegKeyExists(HKEY_LOCAL_MACHINE, 'SYSTEM\CurrentControlSet\Services\Bonjour Service');
  if Result then
    Log('Bonjour Service is already installed.')
  else
    Log('Bonjour Service is not installed. Will download and install it.');
end;

// Function to download Bonjour installer if not installed
function PrepareToInstall(var NeedsRestart: Boolean): String;
var
  DownloadPage: TDownloadWizardPage;
begin
  Result := '';
  
  // If Bonjour is not installed, download the installer
  if not IsBonjourInstalled then
  begin
    // Show custom message about Bonjour requirement
    MsgBox('UXPlay requires Bonjour for AirPlay functionality. Bonjour will be installed during setup.', mbInformation, MB_OK);
    
    DownloadPage := CreateDownloadPage(SetupMessage(msgWizardPreparing), 'Downloading Bonjour (required for AirPlay functionality)', nil);
    
    DownloadPage.Add('https://download.info.apple.com/Mac_OS_X/061-8098.20100603.gthyu/BonjourPSSetup.exe', 'BonjourPSSetup.exe', '');
    DownloadPage.Show;
    try
      try
        DownloadPage.Download;
        Result := '';
      except
        Result := 'Error downloading Bonjour. ' + GetExceptionMessage;
      end;
    finally
      DownloadPage.Hide;
    end;
  end;
end;

// Show a message during installation indicating Bonjour installation status
procedure CurStepChanged(CurStep: TSetupStep);
begin
  if CurStep = ssInstall then
  begin
    if not IsBonjourInstalled then
      Log('Will install Bonjour as part of the setup as it is required for AirPlay functionality.')
    else
      Log('Skipping Bonjour installation as it is already installed.');
  end;
end;

// Helper function to check if a process is running
function IsProcessRunning(const ProcessName: string): Boolean;
var
  ResultCode: Integer;
begin
  // Using tasklist to check if process is running, redirecting output to nul
  // Exit code 0 means process was found, 1 means it wasn't
  if Exec('cmd.exe', '/c tasklist /FI "IMAGENAME eq ' + ProcessName + '" /NH | find "' + ProcessName + '" > nul', '', SW_HIDE, ewWaitUntilTerminated, ResultCode) then
    Result := (ResultCode = 0)
  else
    Result := False; // If command failed, assume process is not running
end;

// Function to terminate a process
function TerminateProcess(const ProcessName: string; ForceTerminate: Boolean): Boolean;
var
  ResultCode: Integer;
  Params: string;
begin
  if ForceTerminate then
    Params := '/f /im ' + ProcessName
  else
    Params := '/im ' + ProcessName;
    
  Result := Exec('taskkill.exe', Params, '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
end;

// Function to handle uninstallation initialization
function InitializeUninstall: Boolean;
var
  UninstallBonjour: Boolean;
  ResultCode: Integer;
  BonjourUninstall: String;
  BonjourDisplayName: String;
  BonjourGUID: String;
  Index: Integer;
  FindRec: TFindRec;
  UninstallRoot: String;
  UninstallKeys: array of String;
begin
  Result := True;
  
  // First check if our app is running and terminate it with increasing force
  if IsProcessRunning('{#MyAppExeName}') then
  begin
    Log('Application is running. Attempting to close it gracefully...');
    TerminateProcess('{#MyAppExeName}', False);
    
    // Wait a bit for the application to close
    Sleep(1000);
    
    // If still running, force kill
    if IsProcessRunning('{#MyAppExeName}') then
    begin
      Log('Application still running. Forcing termination...');
      TerminateProcess('{#MyAppExeName}', True);
      Sleep(2000); // Wait longer after forced termination
    end;
  end;
  
  // Also check for uxplay.exe process and terminate if needed
  if IsProcessRunning('uxplay.exe') then
  begin
    Log('uxplay.exe is running. Attempting to close it...');
    TerminateProcess('uxplay.exe', False);
    
    Sleep(1000);
    
    if IsProcessRunning('uxplay.exe') then
    begin
      Log('uxplay.exe still running. Forcing termination...');
      TerminateProcess('uxplay.exe', True);
      Sleep(2000);
    end;
  end;
  
  // Ask if user wants to uninstall Bonjour as well
  if IsBonjourInstalled then
  begin
    UninstallBonjour := MsgBox('Would you like to uninstall Bonjour as well?' + #13#10 + 
                              '(Note: Only uninstall if no other applications need it)',
                              mbConfirmation, MB_YESNO) = IDYES;
                              
    if UninstallBonjour then
    begin
      Log('User chose to uninstall Bonjour. Looking for uninstaller...');
      
      // Define the registry paths we need to check
      SetArrayLength(UninstallKeys, 2);
      UninstallKeys[0] := 'SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall';
      UninstallKeys[1] := 'SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall';
      
      BonjourGUID := '';
      
      // Search through potential registry locations
      for Index := 0 to GetArrayLength(UninstallKeys) - 1 do
      begin
        UninstallRoot := UninstallKeys[Index];
        if RegGetSubkeyNames(HKEY_LOCAL_MACHINE, UninstallRoot, FindRec) then
        begin
          repeat
            // Check if this entry is Bonjour
            if RegQueryStringValue(HKEY_LOCAL_MACHINE, UninstallRoot + '\' + FindRec.Name, 'DisplayName', BonjourDisplayName) then
            begin
              if (Pos('Bonjour', BonjourDisplayName) > 0) or (Pos('BONJOUR', BonjourDisplayName) > 0) or (Pos('bonjour', BonjourDisplayName) > 0) then
              begin
                BonjourGUID := FindRec.Name;
                Log('Found Bonjour GUID: ' + BonjourGUID);
                Break;
              end;
            end;
          until not RegNextKey(FindRec);
          RegCloseKey(FindRec.Handle);
          
          if BonjourGUID <> '' then
            Break;
        end;
      end;
      
      // If we found the GUID, run the uninstaller
      if BonjourGUID <> '' then
      begin
        // Get uninstall string
        if RegQueryStringValue(HKEY_LOCAL_MACHINE, UninstallRoot + '\' + BonjourGUID, 'UninstallString', BonjourUninstall) then
        begin
          Log('Found Bonjour uninstall command: ' + BonjourUninstall);
          
          // Check if it's an MSI uninstall
          if Pos('MsiExec.exe', BonjourUninstall) > 0 then
          begin
            // Modify to make it quiet
            if Pos('/I', BonjourUninstall) > 0 then
              StringChangeEx(BonjourUninstall, '/I', '/X', True);
              
            BonjourUninstall := BonjourUninstall + ' /qn';
            Log('Running uninstall command: ' + BonjourUninstall);
            
            if not Exec(ExpandConstant('{sys}\cmd.exe'), '/c ' + BonjourUninstall, '', SW_HIDE, ewWaitUntilTerminated, ResultCode) then
            begin
              Log('Failed to run Bonjour uninstaller via cmd. Trying direct execution.');
              if not Exec('msiexec.exe', '/X' + BonjourGUID + ' /qn', '', SW_HIDE, ewWaitUntilTerminated, ResultCode) then
                Log('Failed to uninstall Bonjour with msiexec directly')
              else
                Log('Bonjour uninstalled with direct msiexec. Exit code: ' + IntToStr(ResultCode));
            end else
              Log('Bonjour uninstall command executed. Exit code: ' + IntToStr(ResultCode));
          end else
          begin
            // Not MSI, try to execute the uninstall string directly
            Log('Non-MSI uninstall string detected. Trying to execute directly.');
            if not Exec(BonjourUninstall, '', '', SW_HIDE, ewWaitUntilTerminated, ResultCode) then
              Log('Failed to execute Bonjour uninstaller')
            else
              Log('Bonjour uninstaller executed. Exit code: ' + IntToStr(ResultCode));
          end;
        end else
          Log('Could not find Bonjour uninstall string in registry');
      end else
      begin
        // Fallback to alternative methods
        Log('Could not find Bonjour registry entry. Trying alternative methods.');
        
        // Try msiexec with known Bonjour product codes
        if not Exec('msiexec.exe', '/X{94D02855-73F8-4133-A80D-1EEBB412A487} /qn', '', SW_HIDE, ewWaitUntilTerminated, ResultCode) then
          Log('Failed to uninstall Bonjour using default product code.')
        else
          Log('Attempted Bonjour uninstall with known product code. Exit code: ' + IntToStr(ResultCode));
          
        // Last resort: try wmic approach
        if Exec('wmic', 'product where "name like ''%Bonjour%''" call uninstall /nointeractive', '', SW_SHOW, ewWaitUntilTerminated, ResultCode) then
          Log('Bonjour uninstall command executed via wmic. Exit code: ' + IntToStr(ResultCode))
        else
          Log('Failed to execute Bonjour uninstall command via wmic');
          
        // Also try mdss variant just in case
        if Exec('wmic', 'product where "name like ''%mdns%''" call uninstall /nointeractive', '', SW_SHOW, ewWaitUntilTerminated, ResultCode) then
          Log('mDNS uninstall command executed via wmic. Exit code: ' + IntToStr(ResultCode));
      end;
    end;
  end;
end;

// Function to handle post-uninstall cleanup, ensuring all files are removed
procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep);
var
  AppPath: string;
  ResultCode: Integer;
begin
  if CurUninstallStep = usPostUninstall then
  begin
    AppPath := ExpandConstant('{app}');
    
    // Double-check if the directory still exists
    if DirExists(AppPath) then
    begin
      Log('Application directory still exists after uninstall. Attempting final cleanup...');
      
      // Make sure no processes are locking the directory
      if IsProcessRunning('{#MyAppExeName}') then
      begin
        Log('Application process still found. Forcing termination...');
        TerminateProcess('{#MyAppExeName}', True);
        Sleep(3000); // Wait even longer to ensure process is fully terminated
      end;
      
      // Also check for uxplay.exe process again
      if IsProcessRunning('uxplay.exe') then
      begin
        Log('uxplay.exe process still found. Forcing termination...');
        TerminateProcess('uxplay.exe', True);
        Sleep(3000);
      end;
      
      // Final attempt to remove the directory
      if not DelTree(AppPath, True, True, True) then
      begin
        Log('Failed to remove directory using DelTree. Attempting with cmd...');
        // Try with RD command which sometimes works better
        Exec('cmd.exe', '/c rd /s /q "' + AppPath + '"', '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
      end;
      
      // Inform user if we couldn't remove everything
      if DirExists(AppPath) then
        Log('WARNING: Could not completely remove application directory.')
      else
        Log('Application directory successfully removed.');
    end;
  end;
end;
