; Script generated by the Inno Setup Script Wizard.
; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!

#define MyAppName "uxplay-windows"
#define MyAppVersion "1.72"
#define MyAppPublisher "leapbtw"
#define MyAppURL "https://github.com/leapbtw/uxplay-windows"
#define MyAppExeName "uxplay-windows.exe"

[Setup]
; NOTE: The value of AppId uniquely identifies this application. Do not use the same AppId value in installers for other applications.
; (To generate a new GUID, click Tools | Generate GUID inside the IDE.)
AppId={{02621F03-7F92-4E33-AA17-017F79B31DCF}
AppName={#MyAppName}
AppVersion={#MyAppVersion}
;AppVerName={#MyAppName} {#MyAppVersion}
AppPublisher={#MyAppPublisher}
AppPublisherURL={#MyAppURL}
AppSupportURL={#MyAppURL}
AppUpdatesURL={#MyAppURL}
DefaultDirName={autopf}\{#MyAppName}
DisableProgramGroupPage=yes
; Uncomment the following line to run in non administrative install mode (install for current user only.)
;PrivilegesRequired=lowest
OutputBaseFilename=uxplay-windows
SetupIconFile=D:\a\uxplay-windows\uxplay-windows\icon.ico
Compression=lzma
SolidCompression=yes
WizardStyle=modern
UninstallDisplayIcon={app}\{#MyAppExeName}
; Enhanced uninstall settings
CloseApplications=force
RestartApplications=no
; This setting allows us to handle everything in the uninstall process
UninstallRestartComputer=no

[Languages]
Name: "english"; MessagesFile: "compiler:Default.isl"

[Tasks]
Name: "desktopicon"; Description: "{cm:CreateDesktopIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: unchecked

[Files]
Source: "D:\a\uxplay-windows\uxplay-windows\dist\uxplay-windows\{#MyAppExeName}"; DestDir: "{app}"; Flags: ignoreversion
Source: "D:\a\uxplay-windows\uxplay-windows\dist\uxplay-windows\*"; DestDir: "{app}"; Flags: ignoreversion recursesubdirs createallsubdirs
; NOTE: Don't use "Flags: ignoreversion" on any shared system files

; Temporary files for Bonjour installation if needed
Source: "{tmp}\BonjourPSSetup.exe"; DestDir: "{tmp}"; Flags: deleteafterinstall external; ExternalSize: 2000000; Check: not IsBonjourInstalled

[Messages]
; Custom message for Bonjour installation requirements
BonjourRequired=UXPlay requires Bonjour for AirPlay functionality. Bonjour will be installed during setup.

[Icons]
Name: "{autoprograms}\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"
Name: "{autodesktop}\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"; Tasks: desktopicon

[Run]
; Install Bonjour if not already installed
Filename: "{tmp}\BonjourPSSetup.exe"; Parameters: "/extract"; Flags: waituntilterminated runhidden; Check: not IsBonjourInstalled; StatusMsg: "Preparing Bonjour installation (required for AirPlay)..."
Filename: "cmd.exe"; Parameters: "/c expand ""{tmp}\BonjourPS.msi"" -F:* ""{tmp}"""; Flags: waituntilterminated runhidden; Check: not IsBonjourInstalled
Filename: "msiexec.exe"; Parameters: "/i ""{tmp}\Bonjour64.msi"" /qn"; Flags: waituntilterminated; StatusMsg: "Installing Bonjour (required for AirPlay)..."; Check: not IsBonjourInstalled

; Launch the application after installation
Filename: "{app}\{#MyAppExeName}"; Description: "{cm:LaunchProgram,{#StringChange(MyAppName, '&', '&&')}}"; Flags: shellexec postinstall skipifsilent

[UninstallRun]
; First terminate any running instances more aggressively
Filename: "taskkill.exe"; Parameters: "/f /im {#MyAppExeName}"; Flags: runhidden skipifdoesntexist
; Also terminate uxplay.exe which might be a separate process
Filename: "taskkill.exe"; Parameters: "/f /im uxplay.exe"; Flags: runhidden skipifdoesntexist

[InstallDelete]
; Clean up any leftover files during installation/reinstallation
Type: filesandordirs; Name: "{app}"

[UninstallDelete]
; Make absolutely sure we delete everything during uninstall
Type: filesandordirs; Name: "{app}"

[Code]
// Function to check if Bonjour is installed by checking registry key
function IsBonjourInstalled: Boolean;
begin
  Result := RegKeyExists(HKEY_LOCAL_MACHINE, 'SYSTEM\CurrentControlSet\Services\Bonjour Service');
  if Result then
    Log('Bonjour Service is already installed.')
  else
    Log('Bonjour Service is not installed. Will download and install it.');
end;

// Function to download Bonjour installer if not installed
function PrepareToInstall(var NeedsRestart: Boolean): String;
var
  DownloadPage: TDownloadWizardPage;
begin
  Result := '';
  
  // If Bonjour is not installed, download the installer
  if not IsBonjourInstalled then
  begin
    // Show custom message about Bonjour requirement
    MsgBox(ExpandConstant('{cm:BonjourRequired}'), mbInformation, MB_OK);
    
    DownloadPage := CreateDownloadPage(SetupMessage(msgWizardPreparing), 'Downloading Bonjour (required for AirPlay functionality)', nil);
    
    DownloadPage.Add('https://download.info.apple.com/Mac_OS_X/061-8098.20100603.gthyu/BonjourPSSetup.exe', 'BonjourPSSetup.exe', '');
    DownloadPage.Show;
    try
      try
        DownloadPage.Download;
        Result := '';
      except
        Result := 'Error downloading Bonjour. ' + GetExceptionMessage;
      end;
    finally
      DownloadPage.Hide;
    end;
  end;
end;

// Show a message during installation indicating Bonjour installation status
procedure CurStepChanged(CurStep: TSetupStep);
begin
  if CurStep = ssInstall then
  begin
    if not IsBonjourInstalled then
      Log('Will install Bonjour as part of the setup as it is required for AirPlay functionality.')
    else
      Log('Skipping Bonjour installation as it is already installed.');
  end;
end;

// Helper function to check if a process is running
function IsProcessRunning(const ProcessName: string): Boolean;
var
  ResultCode: Integer;
begin
  // Using tasklist to check if process is running, redirecting output to nul
  // Exit code 0 means process was found, 1 means it wasn't
  if Exec('cmd.exe', '/c tasklist /FI "IMAGENAME eq ' + ProcessName + '" /NH | find "' + ProcessName + '" > nul', '', SW_HIDE, ewWaitUntilTerminated, ResultCode) then
    Result := (ResultCode = 0)
  else
    Result := False; // If command failed, assume process is not running
end;

// Function to terminate a process
function TerminateProcess(const ProcessName: string; ForceTerminate: Boolean): Boolean;
var
  ResultCode: Integer;
  Params: string;
begin
  if ForceTerminate then
    Params := '/f /im ' + ProcessName
  else
    Params := '/im ' + ProcessName;
    
  Result := Exec('taskkill.exe', Params, '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
end;

// Function to handle uninstallation initialization
function InitializeUninstall(): Boolean;
var
  UninstallBonjour: Boolean;
  ResultCode: Integer;  // Added ResultCode variable declaration
  MsiExecParams: String;
  BonjourProductCode: String;
begin
  Result := True;
  
  // First check if our app is running and terminate it with increasing force
  if IsProcessRunning('{#MyAppExeName}') then
  begin
    Log('Application is running. Attempting to close it gracefully...');
    TerminateProcess('{#MyAppExeName}', False);
    
    // Wait a bit for the application to close
    Sleep(1000);
    
    // If still running, force kill
    if IsProcessRunning('{#MyAppExeName}') then
    begin
      Log('Application still running. Forcing termination...');
      TerminateProcess('{#MyAppExeName}', True);
      Sleep(2000); // Wait longer after forced termination
    end;
  end;
  
  // Also check for uxplay.exe process and terminate if needed
  if IsProcessRunning('uxplay.exe') then
  begin
    Log('uxplay.exe is running. Attempting to close it...');
    TerminateProcess('uxplay.exe', False);
    
    Sleep(1000);
    
    if IsProcessRunning('uxplay.exe') then
    begin
      Log('uxplay.exe still running. Forcing termination...');
      TerminateProcess('uxplay.exe', True);
      Sleep(2000);
    end;
  end;
  
  // Ask if user wants to uninstall Bonjour as well
  if IsBonjourInstalled then
  begin
    UninstallBonjour := MsgBox('Would you like to uninstall Bonjour as well?' + #13#10 + 
                              '(Note: Only uninstall if no other applications need it)',
                              mbConfirmation, MB_YESNO) = IDYES;
                              
    if UninstallBonjour then
    begin
      Log('User chose to uninstall Bonjour. Executing uninstaller...');
      
      // Try to get the Bonjour product code from registry
      if RegQueryStringValue(HKEY_LOCAL_MACHINE, 'SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\Bonjour', 'UninstallString', BonjourProductCode) or
         RegQueryStringValue(HKEY_LOCAL_MACHINE, 'SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\Bonjour', 'UninstallString', BonjourProductCode) then
      begin
        // Extract product code from the uninstall string if found
        Log('Found Bonjour uninstall string: ' + BonjourProductCode);
        
        // Most MSI uninstall strings look like: MsiExec.exe /I{PRODUCT-CODE}
        // We need to extract the product code and change /I to /X for uninstall
        if Pos('/I{', BonjourProductCode) > 0 then
        begin
          Delete(BonjourProductCode, 1, Pos('/I{', BonjourProductCode) + 1); // Remove "MsiExec.exe /I"
          if Pos('}', BonjourProductCode) > 0 then
          begin
            BonjourProductCode := Copy(BonjourProductCode, 1, Pos('}', BonjourProductCode));
            Log('Extracted Bonjour product code: ' + BonjourProductCode);
            
            // Build the uninstall command with quiet options
            MsiExecParams := '/X' + BonjourProductCode + ' /qn';
            Log('Running msiexec with params: ' + MsiExecParams);
            
            // Run the uninstaller with proper parameters
            if Exec('msiexec.exe', MsiExecParams, '', SW_HIDE, ewWaitUntilTerminated, ResultCode) then
              Log('Bonjour uninstall command executed successfully with code: ' + IntToStr(ResultCode))
            else
              Log('Failed to execute Bonjour uninstall command');
          end else
            Log('Could not parse product code properly');
        end else
          Log('Uninstall string format not recognized');
      end else
      begin
        // Fallback method using wmic
        Log('Could not find Bonjour uninstall info in registry. Trying wmic method...');
        if Exec('wmic', 'product where "name like ''%Bonjour%''" call uninstall /nointeractive', '', SW_HIDE, ewWaitUntilTerminated, ResultCode) then
          Log('Bonjour uninstall command executed successfully with wmic')
        else
          Log('Failed to execute Bonjour uninstall command with wmic');
      end;
    end;
  end;
end;

// Function to handle post-uninstall cleanup, ensuring all files are removed
procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep);
var
  AppPath: string;
  ResultCode: Integer;  // Added ResultCode variable declaration
begin
  if CurUninstallStep = usPostUninstall then
  begin
    AppPath := ExpandConstant('{app}');
    
    // Double-check if the directory still exists
    if DirExists(AppPath) then
    begin
      Log('Application directory still exists after uninstall. Attempting final cleanup...');
      
      // Make sure no processes are locking the directory
      if IsProcessRunning('{#MyAppExeName}') then
      begin
        Log('Application process still found. Forcing termination...');
        TerminateProcess('{#MyAppExeName}', True);
        Sleep(3000); // Wait even longer to ensure process is fully terminated
      end;
      
      // Also check for uxplay.exe process again
      if IsProcessRunning('uxplay.exe') then
      begin
        Log('uxplay.exe process still found. Forcing termination...');
        TerminateProcess('uxplay.exe', True);
        Sleep(3000);
      end;
      
      // Final attempt to remove the directory
      if not DelTree(AppPath, True, True, True) then
      begin
        Log('Failed to remove directory using DelTree. Attempting with cmd...');
        // Try with RD command which sometimes works better
        Exec('cmd.exe', '/c rd /s /q "' + AppPath + '"', '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
      end;
      
      // Inform user if we couldn't remove everything
      if DirExists(AppPath) then
        Log('WARNING: Could not completely remove application directory.')
      else
        Log('Application directory successfully removed.');
    end;
  end;
end;
